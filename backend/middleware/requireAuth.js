const jwt = require('jsonwebtoken')
const User = require('../models/userModel')

const requireAuth = async (req, res, next) => { // نقوم باستدعاء الوظيفة next بمجرد كانت المصادقة ناجحة بعدها سيتم توجيه الطلب الى معالج في controllers
  // verify user is authenticated
  const { authorization } = req.headers // للحصول على رمز المميز jwt من الطلب 
  // سيتم تخزين في authorization سلسلة كالتالي : 'Bearer dfghjs3kksjklqmknw.1544qfrqhjjqhqqmdsfg.skjsgffnfbvddsgsvq2' 
  // وسنحتاج الى تقسيمها لجزئين واخذ فقط الرمز المميز وتجاهل الجزء الذي فيه Bearer

  if (!authorization) {
    return res.status(401).json({error: 'Authorization token required'}) // "رمز التفويض مطلوب"
  }

  const token = authorization.split(' ')[1] // الدالة split تقوم بتقسيم السلسلة الى اقسام بناء على الحرف او الفاصلة او المسافة..الخ التي تحددها بين القوسين ويتم تخزين العناصر في مصفوفة.
                                            // قمنا بتحديد التقسيم بناء على المسافة ليتم تقسيم السلسلة لجزئين وبعدها اخذ الجزء الاخير [1] الموجود فيه الرمز وتخزينه في المتغير token

  try {
    const { _id } = jwt.verify(token, process.env.SECRET) // هذا السطر لتحقق من الرمز وانه سليم ولم يتم العبث به او تغييره. لذلك نقوم بتمرير الرمز token ونقوم بتمرير السر SECRET للتحقق من التوقيع.
    // وسيتم ارجاع لنا payload (حمولة) التي تحتوي على id المستخدم لذلك نأخذ منها فقط المعرف - اذا لم يحصل على الحمولة سيتم ارسال خطأ من catch

    req.user = await User.findOne({ _id }).select('_id') // محاولة العثور على المستخدم في قاعدة البيانات عن طريق المعرف وفي حال العثور على مستند الخاص بالمستخدم بعدها قمنا بتحديد في المستند المعرف فقط وعدم جلب باقي البيانات وتخزين المستند في الكائن user ويمكنك تسميته باي اسم و الذي سيكون مصاحب لطلب عند تمريره عن طريق next الى المعالج المستهدف في controllers.
    next() // لاطلاق وظيفة المعالج التالية 

  } catch (error) { // اذا لم تنجح المصادقة سيتم ارسال استجابة خاطئة ولن يتم تمرير الطلب الى المعالج
    console.log(error)
    res.status(401).json({error: 'Request is not authorized'})
  }
}

module.exports = requireAuth

/*
وظيفة requireAuth
تستخدم للتحقق مما إذا كان المستخدم مصرحًا له بالوصول إلى صفحة معينة أو لا. عادةً ما يتم استخدام هذه الوظيفة كوسيلة لحماية بعض المسارات في تطبيق الويب.

عند استدعاء وظيفة requireAuth، ستقوم بتلقي ثلاثة وسائط: req (طلب العميل)، res (الاستجابة التي سترسلها الخادم)، و next (وظيفة التالية في دورة المعالجة).

أولاً، يتحقق requireAuth من صحة اعتمادات المستخدم. إذا كان المستخدم غير مصرح له بالوصول، فإنه يُرسل ردًا مناسبًا (على سبيل المثال، رسالة خطأ أو إعادة توجيه إلى صفحة تسجيل الدخول).

إذا كان المستخدم مصرحًا به، فإنه يُكمِّل عملية التشغيل باستدعاء وظيفة next. هذه الوظيفة تُستخدَم لنقل التحكُّم إلى وظيفة التالية في دورة المعالجة. عادةً ما يكون هذا هو المسار الذي يأتي بعده في سلسلة وظائف middleware.

بشكل عام، تكون وظائف middleware جزءًا من سلاسل middleware حيث يتم تطبيقها بشكل متسلسل على طول طريق الطلب قبل أن يصِّل إلى المسار النهائي.

*/